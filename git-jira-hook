#!/usr/bin/env python

##########################################################################
# Copyright 2009 Broadcom Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# File: git-jira-hook
# Author: Joyjit Nath
#
###########################################################################

# Purpose:
# This is a git hook, to be used in an environment where git is used
# as the source control and Jira is used for bug tracking.
#
# See accompanying README file for help in using this.
#


import logging
import sys
import os

# Change this value to "CRITICAL/ERROR/WARNING/INFO/DEBUG/NOTSET"
# as appropriate.
loglevel=logging.INFO
# loglevel=logging.DEBUG


import subprocess
import re
import getpass
import stat
import ConfigParser
import string
from suds.client import Client

myname = os.path.basename(sys.argv[0])
global_jirarc = os.path.dirname(sys.argv[0]) + "/../jirarc"
if len(sys.argv) > 1 and sys.argv[1].startswith('--action='):
    action_arg = sys.argv.pop(1)
    myname = action_arg.split('=')[1]

logging.basicConfig(level=loglevel, format="%(levelname)s %(name)s %(message)s")
logging.getLogger('suds').setLevel(logging.INFO)
if loglevel != logging.DEBUG:
    # suds prints out a lot of ERRORs that we don't need to see, since it raises an Exception also
    logging.getLogger('suds.client').setLevel(logging.CRITICAL)
log = logging.getLogger(myname)
def main():
    if myname == "pre-receive":
        return handle_pre_receive()
    else:
        log.error("invoked as '%s'. Need to be invoked as pre-receive. " , myname)
        return -1


# Performs the git "pre_receive" hook
# This hook is triggered on the remote repo, as a result
# of "git push"
def handle_pre_receive():
    buf = sys.stdin.read()
    log.debug("handle_pre_receive: stdin='%s'", buf)
    (old_commit_id, new_commit_id, ref) =  string.split(buf, ' ')

    if old_commit_id == None or new_commit_id == None or ref == None:
        log.error("post-receive hook stdin is incorrect '%s'", buf)
        return -1

    branch = git_get_branchname_from_ref(ref)
    if not enabled_on_branch(branch):
        return 0

    jira_url = get_jira_url()
    if jira_url == None:
        return -1

    (jira_soap_client, jira_auth) = jira_start_session(jira_url)
    if jira_soap_client == None or jira_auth == None:
        return -1

    zeros = '0000000000000000000000000000000000000000'
    if new_commit_id == zeros:
        log.debug('branch at %s deleted' % old_commit_id)
        return 0

    commit_text = git_get_commit_msg(new_commit_id)
    #print "new_commit_text=",commit_text
    if validate_commit_text(jira_soap_client, jira_auth, commit_text, new_commit_id) == -1:
        log.error("Please add any referenced Jira issue e.g. VOT-14 in commit message for commit id: %s", new_commit_id)
        return -1
    else:
        jira_add_comment(jira_soap_client, jira_auth, new_commit_id, commit_text, branch)

    return 0


def validate_commit_text(jira_soap_client, jira_auth, commit_text, commit_id):

    refed_issue_count = call_pattern_hook(commit_text, "", \
            jira_find_issue, jira_soap_client, jira_auth, commit_id)

    progress_issue_count = call_pattern_hook(commit_text, "progress ", \
            jira_find_issue, jira_soap_client, jira_auth, commit_id)

    resolve_issue_count = call_pattern_hook(commit_text, "resolve ", \
            jira_find_issue, jira_soap_client, jira_auth, commit_id)

    close_issue_count = call_pattern_hook(commit_text, "close ", \
            jira_find_issue, jira_soap_client, jira_auth, commit_id)

    reopen_issue_count = call_pattern_hook(commit_text, "reopen ", \
            jira_find_issue, jira_soap_client, jira_auth, commit_id)

    if refed_issue_count + progress_issue_count + resolve_issue_count + close_issue_count + reopen_issue_count == 0:
            return -1

    return 0


def jira_add_comment(jira_soap_client, jira_auth, commit_id, commit_text, branch):
    gitweb_url = get_gitweb_url()
    gitweb_branch_url = get_gitweb_branch_url()

    # commit_text is git's pretty (medium) format
    commit_msg_only = ''.join(commit_text.splitlines()[4:])
    jira_text = commit_text
    if gitweb_branch_url:
        jira_text = jira_text.replace(commit_id, commit_id + ' on branch [%s|%s]'
                                          % (branch, gitweb_branch_url + branch))
    if gitweb_url != None or gitweb_url != "":
        jira_text = jira_text.replace(commit_id, \
            "[" + commit_id + "|" + gitweb_url + commit_id + "]")

    call_pattern_hook(commit_msg_only, '', jira_add_comment_to_issue, \
                                jira_soap_client, jira_auth, jira_text)
    call_pattern_hook(commit_msg_only, 'progress ', jira_add_comment_to_and_progress_issue, \
                                jira_soap_client, jira_auth, jira_text)
    call_pattern_hook(commit_msg_only, 'resolve ', jira_add_comment_to_and_resolve_issue, \
                                jira_soap_client, jira_auth, jira_text)
    call_pattern_hook(commit_msg_only, 'close ', jira_add_comment_to_and_close_issue, \
                                jira_soap_client, jira_auth, jira_text)
    call_pattern_hook(commit_msg_only, 'reopen ', jira_add_comment_to_and_reopen_issue, \
                                jira_soap_client, jira_auth, jira_text)
    return



# Given a function pointer, iterates through the commit message
# text for Jira magic words, and calls the function repeatedly
# returns number of issues found and touched
# in case of error, return -1
def call_pattern_hook(text, pattern, hookfn, jira_soap_client, jira_auth, jira_text):
    if not callable(hookfn):
        log.error("Hook function is not callable");
        exit(-1)

    magic = re.compile(pattern + '(\w\w*-\d\d*)')

    iterator = magic.finditer(text)
    issue_count = 0
    seen_issues = set()
    for match in iterator:
        issuekey = match.group(1)
        #print "issuekey found=", issuekey
        if issuekey in seen_issues:
            continue
        else:
            seen_issues.add(issuekey)
        ret = hookfn(issuekey, jira_soap_client, jira_auth, jira_text)
        if ret != 0:
            return -1
        else:
            issue_count += 1

    return issue_count

#-----------------------------------------------------------------------------
# Jira helper functions
#


# Given a Jira server URL (which is stored in git config)
# Starts an authenticated jira session using SOAP api
# Returns a list of the SOAP object and the authentication token
def jira_start_session(jira_url):
    jira_url = jira_url.rstrip("/")
    try:
        soap_client = Client(jira_url + "/rpc/soap/jirasoapservice-v2?wsdl")
        # print "self.soap_client set", self.soap_client

    except KeyboardInterrupt:
        log.info("... interrupted")

    except Exception, e:
        save_jira_cached_auth(jira_url, "")
        log.error("Invalid Jira URL: '%s'", jira_url)
        log.debug(e)
        return -1

    auth = jira_login(jira_url, soap_client)
    if auth == None:
        return (None, None)

    return (soap_client, auth)

# Try to use the cached authentication object to log in
# to Jira first. ("implicit")
# if that fails, then prompt the user ("explicit")
# for username/password
def jira_login(jira_url, soap_client):

    auth = get_jira_cached_auth(jira_url)
    if auth:
        auth = jira_implicit_login(soap_client, auth)

    if not auth:
        username = get_cfg_value(os.environ['HOME'] + "/.jirarc", jira_url, "username", True)
        password = get_cfg_value(os.environ['HOME'] + "/.jirarc", jira_url, "password", True)
	try:
            auth = soap_client.service.login(username, password)
	except:
            auth = None

    # If the user based version was unsuccessful, try the project one
    if not auth:
        username = get_cfg_value(global_jirarc, jira_url, "username")
        password = get_cfg_value(global_jirarc, jira_url, "password")
        auth = soap_client.service.login(username, password)

    if not auth:
        save_jira_cached_auth(jira_url, "")
        auth = jira_explicit_login(soap_client)

    if auth:
        save_jira_cached_auth(jira_url, auth)

    return auth

def jira_implicit_login(soap_client, auth):

    # test jira to see if auth is valid
    try:
        jira_types = soap_client.service.getIssueTypes(auth)

        # we made it ok
        return auth
    except KeyboardInterrupt:
        log.info("... interrupted")

    except Exception, e:
        log.debug("Previous Jira login is invalid or has expired")
        # log.debug(e)


    return None

def jira_explicit_login(soap_client):
    max_retry_count = 3
    retry_count = 0

    while retry_count < max_retry_count:
        if retry_count > 0:
            log.info("Invalid Jira password/username combination, try again")

        # We now need to read the Jira username/password from
        # the console.
        # However, there is a problem. When git hooks are invoked
        # stdin is pointed to /dev/null, see here:
        # http://kerneltrap.org/index.php?q=mailarchive/git/2008/3/4/1062624/thread
        # The work-around is to re-assign stdin back to /dev/tty , as per
        # http://mail.python.org/pipermail/patches/2002-February/007193.html
        sys.stdin = open('/dev/tty', 'r')

        username = raw_input('Jira username: ')
        password = getpass.getpass('Jira password: ')

        # print "abc"
        # print "self.soap_client login...%s " % username + password
        try:
            auth = soap_client.service.login(username, password)

            try:
                jira_types = soap_client.service.getIssueTypes(auth)
                return auth

            except KeyboardInterrupt:
                log.info("... interrupted")

            except Exception,e:
                log.error("User '%s' does not have access to Jira issues")
                return None

        except KeyboardInterrupt:
            log.info("... interrupted")

        except Exception,e:
            log.debug("Login failed")

        auth=None
        retry_count = retry_count + 1


    if auth == None:
        log.error("Invalid Jira password/username combination")

    return auth



def jira_find_issue(issuekey, jira_soap_client, jira_auth, jira_text):
    try:
        issue = jira_soap_client.service.getIssue(jira_auth, issuekey)
        log.debug("Found issue '%s' in Jira: (%s)",
                    issuekey, issue["summary"])
        return 0

    except KeyboardInterrupt:
        log.info("... interrupted")

    except Exception, e:
        log.error("No such issue '%s' in Jira", issuekey)
        log.debug(e)


def jira_add_comment_to_issue(issuekey, jira_soap_client, jira_auth, jira_text):
    try:
        jira_soap_client.service.addComment(jira_auth, issuekey, {"body":jira_text})
        log.debug("Added to issue '%s' in Jira:\n%s", issuekey, jira_text)
        return 0

    except Exception, e:
        log.error("Error adding comment to issue '%s' in Jira", issuekey)
        log.debug(e)
        return -1


def jira_add_comment_to_and_progress_issue(issuekey, jira_soap_client, jira_auth, jira_text):
    try:
        jira_soap_client.service.progressWorkflowAction(jira_auth, issuekey, '4', [])
        log.debug("Start progress issue '%s' in Jira", issuekey)
        return 0

    except Exception, e:
        log.error("Error start progressing issue '%s' in Jira", issuekey)
        log.debug(e)
        return -1


def jira_add_comment_to_and_resolve_issue(issuekey, jira_soap_client, jira_auth, jira_text):
    try:
        jira_soap_client.service.progressWorkflowAction(jira_auth, issuekey, '5', [])
        log.debug("Resolve issue '%s' in Jira", issuekey)
        return 0

    except Exception, e:
        log.error("Error resolving issue '%s' in Jira", issuekey)
        log.debug(e)
        return -1


def jira_add_comment_to_and_reopen_issue(issuekey, jira_soap_client, jira_auth, jira_text):
    try:
        jira_soap_client.service.progressWorkflowAction(jira_auth, issuekey, '3', [])
        log.debug("Reopen issue '%s' in Jira", issuekey)
        return 0

    except Exception, e:
        log.error("Error reopening issue '%s' in Jira", issuekey)
        log.debug(e)
        return -1



def jira_add_comment_to_and_close_issue(issuekey, jira_soap_client, jira_auth, jira_text):
    try:
        jira_soap_client.service.progressWorkflowAction(jira_auth, issuekey, '2', [])
        log.debug("Close issue '%s' in Jira", issuekey)
        return 0

    except Exception, e:
        log.error("Error closing issue '%s' in Jira", issuekey)
        log.debug(e)
        return -1


#-----------------------------------------------------------------------------
# Miscellaneous Jira related utility functions
#
def get_jira_url():
    jira_url = git_config_get("jira.url")
    if jira_url == None or jira_url == "":
        log.error("Jira URL is not set. Please use 'git config jira.url <actual-jira-url> to set it'")
        return None

    return jira_url

def get_jira_cached_auth(jira_url):
    value =  get_cfg_value(os.environ['HOME'] + "/.jirarc", jira_url, "auth", silent=True)
    if not value:
    	value =  get_cfg_value(global_jirarc, jira_url, "auth", silent=True)
    return value

def save_jira_cached_auth(jira_url, auth):
    file_path = os.environ['HOME'] + "/.jirarc"
    value = None
    if os.path.isfile(file_path):
        value = save_cfg_value(os.environ['HOME'] + "/.jirarc", jira_url, "auth", auth)
    if not value:
        value = save_cfg_value(global_jirarc, jira_url, "auth", auth)


#---------------------------------------------------------------------
# Misc. helper functions
#

def get_gitweb_url():
    value = git_config_get("gitweb.url")
    value = value.replace("%PROJECTNAME%", os.path.abspath(sys.argv[0]+"/../../").replace(git_config_get("gitweb.root")+"/",""))
    log.debug("Gitweb URL = " + value)
    return value

def get_gitweb_branch_url():
    value =  git_config_get("gitweb.branchurl")
    value = value.replace("%PROJECTNAME%", os.path.abspath(sys.argv[0]+"/../../").replace(git_config_get("gitweb.root")+"/",""))
    log.debug("Gitweb URL = " + value)
    return value

def get_cfg_value(cfg_file_name, section, key, silent=False):
    try:
        cfg = ConfigParser.ConfigParser()
        cfg.read(cfg_file_name)
        value = cfg.get(section, key)
    except:
        if not silent:
            log.warn("Error reading %s looking for [%s] %s" % (cfg_file_name, section, key), exc_info=True)
        return None
    return value


def save_cfg_value(cfg_file_name, section, key, value):
    try:
        cfg = ConfigParser.SafeConfigParser()
    except Exception, e:
        log.warning("Failed to instantiate a ConfigParser object")
        log.debug(e)
        return None

    try:
        cfg.read(cfg_file_name)
    except Exception, e:
        log.warning("Failed to read " + cfg_file_name)
        log.debug(e)
        return None

    try:
        cfg.add_section(section)
    except ConfigParser.DuplicateSectionError,e:
        log.debug("Section '%s' already exists in '%s'", section, cfg_file_name)

    try:
        cfg.set(section, key, value)
    except Exception,e:
        log.warning("Failed to add '%s' to '%s'", key, cfg_file_name)
        log.debug(e)

    try:
        cfg.write(open(cfg_file_name, 'wb'))
    except Exception, e:
        log.warning("Failed to write '%s'='%s' to file %s", key, value, cfg_file_name)
        log.debug(e)
        return None
    return 1

# given a string, executes it as an executable, and returns the STDOUT
# as a string
def get_shell_cmd_output(cmd):
    try:
        proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        return proc.stdout.read().rstrip('\n')
    except KeyboardInterrupt:
        log.info("... interrupted")

    except Exception, e:
        log.error("Failed trying to execute '%s'", cmd)

#----------------------------------------------------------------------------
# git helper functions
#

# Read git config of "git-jira-hook.branches"
# Parse out the comma (and space) separated list of
# branch names.
# Then compare against current branchname to see
# if we need to be enabled.
# Return False if we should not be enabled
def enabled_on_branch(current_branchname):
    log.debug("Test if '%s' is enabled...", current_branchname)
    if current_branchname is None:
        # e.g. a tag
        return False
    branchstr = git_config_get("git-jira-hook.branches")
    if branchstr == None or string.strip(branchstr) == "":
        log.debug("All branches enabled")
        return not False

    branchlist = string.split(branchstr, ',')

    for branch in branchlist:
        branch = string.strip(branch)
        if current_branchname == branch:
            log.debug("Current branch '%s' is enabled", current_branchname)
            return not False

    log.debug("Curent branch '%s' is NOT enabled", current_branchname)
    return False

# Get our current branchname
def git_get_curr_branchname():
    buf = get_shell_cmd_output("git branch --no-color")
    # buf is a multiline output, each line containing a branch name
    # the line that starts with a "*" contains the current branch name

    m = re.search("^\* .*$", buf, re.MULTILINE)
    if m == None:
        return None

    return buf[m.start()+2 : m.end()]


# Given a "ref" string (such as while doing a push
# to a remote repo), parse out the branch name
def git_get_branchname_from_ref(ref):
    # "refs/heads/<branchname>"
    if ref.startswith("refs/tags/"):
        return None
    elif not ref.startswith("refs/heads/"):
        log.error("Invalid ref '%s'", ref)
        exit(-1)

    return string.strip(ref[len("refs/heads/"):])


def git_config_get(name):
    return get_shell_cmd_output("git config '" + name + "'")

def git_config_set(name, value):
    os.system("git config " + name + " '" + value + "'")

def git_config_unset(name):
    os.system("git config --unset-all " + name)

def git_get_commit_msg(commit_id):
    return get_shell_cmd_output("git rev-list --pretty --max-count=1 " + commit_id)

def git_get_last_commit_id():
    return get_shell_cmd_output("git log --pretty=format:%H -1")

def git_get_array_of_commit_ids(start_id, end_id):
    output = get_shell_cmd_output("git rev-list --reverse " + start_id + ".." + end_id)
    if output == "":
        return None

    # parse the result into an array of strings
    commit_id_array = string.split(output, '\n')
    return commit_id_array

def git_get_branches_with_commit(commit_id):
    output = get_shell_cmd_output("git branch --contains %s" % commit_id)
    return [b.replace('* ', '').strip() for b in output.split('\n')]

#----------------------------------------------------------------------------
# python script entry point. Dispatches main()
if __name__ == "__main__":
  sys.exit (main())